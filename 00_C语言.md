[TOC]

C语言

编辑器：vim vscode(图形化)  记事本 notepad++

编译器：gcc（代码翻译为电脑可以执行的指令）

调试器：gdb

## linux常用终端指令+如何用vim写一个c语言程序并运行

### 一、常用的命令：

1. cd+要打开的文件名——打开一个文件
2. cat+要打开的文件名——查看一个文件的内容

3. touch+文件名——创建一个该名字的文件

4. /+名字——到该名字的文件，然后  .  表示当前文件   ..就表示上一级文件，~表示home目录

5. ls——列出当前目录的子文件列表;ls -l   ——列出当前目录的子文件列表
6. history 查看过往输入记录
7. history|grep 4（定向搜索和4相关的过往查询记录）
8. mkdir+名字——当前创建一个该名字的文件夹

9. rm+名字——删除一个文件  然后递归删除(删除目录，即文件夹)加上-r，不能复原的删除加上-f（慎用）

10. pwd——返回当前目录的完整路径

11. $美元符号——当前为一个一般的用户进行操作，不能修改一些root文件

12. 如果要获得最高的权限就输入sudo su，然后你的美元符号就变成了￥表示最高级权限

13. 退出该权限是 exit

14. vim是linux里面一个常用的文本编辑软件，也是系统包里自带的，用sudo apt install vim可以进行安装


### 二、如何用vim写一个c程序并运行

1. 用vim打开文件，例如： vim+hello.c（文件名）

2. 按i——插入写代码，然后写一个c的程序

3. 然后按ctrl+c——退出当前状态 （linux终端里面也表示停止）

4. 然后按shift+冒号表示命令

   1. 输入wq表示储存并退出,

   2. `q` 表示退出，`!` 表示强制执行。

      当你输入 `:q!` 后，Vim 将立即退出当前文件，并丢弃任何未保存的更改。

## 运行c语言代码的两种方式

### 1.vscode打开

1. ctrl+shift+【~】组合键调出终端窗口

2. 切换到linux窗口<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240127235242973.png" alt="image-20240127235242973" style="zoom:67%;" />

3. cd到想要打开的.c文件对应的文件夹![image-20240128001952872](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240128001952872.png)


​		tips：在命令行中，双引号用于将包含空格或特殊字符的路径或文件名括起来，以便正确解析路径。如果路径或文件名中包含空格或特殊字符（如`$`、`&`、`*`等），则需要使用双引号将其括起来，以确保命令行正确解析路径。

4. 使用指令gcc 6.c -o 6.out生成6.out文件并运行

![image-20240128131801962](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240128131801962.png)

### 2.linux系统打开

进入想要进行操作的文件所在的文件夹（这代表后续的指令都以该文件作为根目录），shift键+鼠标右击后选择linux shell

![image-20240128132432338](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240128132432338.png)

后续操作同vscode👇

![image-20240128132843938](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240128132843938.png)

## 运算符

在C语言中，大多数运算符的结果不一定是布尔值（即0或1），而是根据操作数的类型和运算符的规则确定的。下面是一些常见的运算符及其结果类型：

1. 算术运算符（如加法、减法、乘法、除法等）的结果是操作数类型相应的值。

2. 关系运算符（如等于、不等于、大于、小于、大于等于、小于等于等）的结果是布尔值（0或1）。

3. 逻辑运算符（如逻辑与`&&`、逻辑或`||`、逻辑非`!`等）的结果是布尔值（0或1）。

4. 赋值运算符（如赋值`=`、复合赋值`+=`、`-=`等）的结果是被赋值的变量的值。

5. 位运算符（如按位与`&`、按位或`|`、按位异或`^`、取反‘~’、二进制左移<<、二进制右移>>）的结果是操作数类型相应的值。

   1.按位或：如果两个相应的位值相同，则结果为 0，否则为 1。eg：

   ```
   0^0=0;   
   0^1=1;   
   1^0=1;  
   1^1=0;
   ```

   2.对操作数的每一位执行逻辑取反操作，即将每一位的 0 变为 1，1 变为 0。

   取反运算符，按二进制位进行"取反"运算。运算规则：

   ```
   ~1=-2;   
   ~0=-1;
   ```

   3.将操作数的所有位向左移动指定的位数。左移 n 位相当于乘以 2 的 n 次方。

   二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。

   4.将操作数的所有位向右移动指定的位数。右移n位相当于除以 2 的 n 次方。

   二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。

6. 其他运算符（如条件运算符`?:`、sizeof运算符等）的结果类型根据运算符的规则来确定。

需要注意的是，C语言中的布尔类型是通过`stdbool.h`头文件引入的`bool`类型，其值只能是`true`或`false`。其他整数类型（如int、char等）在进行逻辑运算时会被隐式转换为布尔值。

**如果你想要明确得到布尔值的结果，可以使用关系运算符或逻辑运算符**，它们的结果就是布尔值。

## 位操作（二进制补码）

二进制补码是一种表示有符号整数的方法，它使用二进制形式来表示正数和负数，并且可以进行简单的加法和减法运算。

在二进制补码表示中，最高位（最左侧的位）被用作符号位。当最高位为0时，表示该数为正数；当最高位为1时，表示该数为负数。

- 正数的二进制补码表示与其原码（二进制绝对值）相同。例如，十进制数+5的二进制补码表示为00000101。

- 负数的二进制补码表示通过以下步骤获得：

1. 首先，将负数的绝对值转换为二进制形式。
2. 然后，将二进制表示中的每个位取反（0变为1，1变为0）。
3. 最后，对取反后的二进制数加1。

例如，十进制数-5的二进制补码表示为11111011。具体步骤如下：

1. 将5的绝对值转换为二进制：00000101。
2. 取反：11111010。
3. 加1：11111011。

- 使用二进制补码表示有符号整数的好处是可以简化加法和减法运算。在进行加法运算时，只需将两个数的二进制补码相加，**忽略最高位的进位**。在进行减法运算时，可以将减法转换为加法，即将减数取反并加1，然后与被减数相加。

例如，对于加法：+3（二进制补码为00000011） + (-2)（二进制补码为11111110），只需将两个二进制补码相加，得到00000001，即十进制数1。

- 对于减法：+3 - (-2)，可以将减法转换为加法：+3 + (+2)。将+2的二进制补码（00000010）与+3的二进制补码（00000011）相加，得到00000101，即十进制数5。

通过使用二进制补码表示，可以简化有符号整数的运算，并且可以避免出现两个零的表示。



## 判断语句

| 语句                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [if 语句](https://www.runoob.com/cprogramming/c-if.html)     | 一个 **if 语句** 由一个布尔表达式后跟一个或多个语句组成。    |
| [if...else 语句](https://www.runoob.com/cprogramming/c-if-else.html) | 一个 **if 语句** 后可跟一个可选的 **else 语句**，else 语句在布尔表达式为假时执行。 |
| [嵌套 if 语句](https://www.runoob.com/cprogramming/c-nested-if.html) | 您可以在一个 **if** 或 **else if** 语句内使用另一个 **if** 或 **else if** 语句。 |
| [switch 语句](https://www.runoob.com/cprogramming/c-switch.html) | 一个 **switch** 语句允许测试一个变量等于多个值时的情况。     |
| [嵌套 switch 语句](https://www.runoob.com/cprogramming/c-nested-switch.html) | 您可以在一个 **switch** 语句内使用另一个 **switch** 语句。   |

tips:当使用多个 if 语句来判断成绩的等级。这样会导致每个条件都被检查，
而不是只检查符合条件的部分,else只和相邻的if对应。

为了避免这种情况，你可以使用 else if 来连接多个条件。
使用 if-else if-else 结构来判断成绩的等级。只有符合条件的第一个分支会被执行，而不会检查后续的条件

### ? : 运算符(三元运算符)

**条件运算符 ? :**，可以用来替代 **if...else** 语句。它的一般形式如下：

```
Exp1 ? Exp2 : Exp3;
```

其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。

? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值。

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240129234406657.png" alt="image-20240129234406657" style="zoom:50%;" />



## 循环语句

### for循环

在C语言中，`for`循环是一种常用的循环结构，用于重复执行一段代码。`for`循环由三个要素组成**：初始化表达式、循环条件和更新表达式**。下面是每个要素的解释：

1. 初始化表达式：在循环开始之前执行一次的表达式，用于初始化循环变量或设置其他需要初始化的值。通常使用一个赋值语句来完成初始化，例如 `int i = 0;`。
2. 循环条件：在每次循环迭代开始之前进行判断的表达式。只有当循环条件为真（非零）时，循环体才会执行。如果循环条件为假（零），循环终止。循环条件通常使用关系运算符（例如 `<`, `>`, `<=`, `>=`, `==`, `!=`）来进行比较，例如 `i < 10`。
3. 更新表达式：在每次循环迭代结束后执行的表达式，用于更新循环变量的值或进行其他需要更新的操作。常见的更新操作是使用递增或递减运算符来增加或减少循环变量的值，例如 `i++` 或 `i--`。

`for`循环的基本语法如下：

```c
for (初始化表达式; 循环条件; 更新表达式) {
    // 循环体
}
```

如果你希望在循环体内使用更新后的值，可以选择前置递增。如果你希望在循环体内使用更新前的值，可以选择后置递增。

### while

while 循环首先检查循环条件，只有当条件为真时才执行循环体。因此，如果条件一开始就为假，那么循环体将永远不会执行。而如果条件一直为真，那么循环将一直执行下去。s

### do while

do while 循环与 while 循环的主要区别在于它们执行循环体的顺序。do while 循环首先执行循环体，然后检查循环条件。因此，即使条件一开始就为假，循环体也会至少执行一次。

## 格式化输入scanf

### 参数构成

1.`scanf` 函数的第一个参数是一个格式字符串，用于指定输入的格式。格式字符串中可以包含转换说明符，例如 `%d`、`%f`、`%s` 等，用于指定要读取的数据类型。

2.`scanf` 函数的后续参数是**要读取的变量的地址**。通过使用变量的地址作为参数，`scanf` 函数可以将输入的值存储到这些变量中。

以下是一个使用 `scanf` 函数读取整数的示例：

```c
int num;
printf("Enter a number: ");
scanf("%d", &num);
printf("You entered: %d\n", num);
```

### 返回值（表示成功读取的输入项目数）

具体来说，`scanf` 函数的返回值有以下几种情况：

- 如果成功读取了至少一个输入项目，返回值将是成功读取的项目数。
- 如果没有成功读取任何项目（例如输入不匹配指定的格式），返回值将是0
- 当检测到文件结尾（end of file） ，返回值为`EOF`（表示文件结束）或者负数（一般是-1）。

以下是一个示例：

```c
int num1, num2;
printf("Enter two numbers: ");
int result = scanf("%d %d", &num1, &num2);
printf("Number of items successfully read: %d\n", result);
```

在上面的代码中，`scanf` 函数尝试读取两个整数，并将成功读取的项目数存储在 `result` 变量中。我们可以使用 `result` 的值来确定读取的成功与否。

如果 `result` 的值等于 2，表示成功读取了两个整数。如果 `result` 的值为 0，则表示没有成功读取任何项目。

### 换行符（啊  我看不懂）

当你使用 `scanf` 函数读取一个字符或字符串时，如果输入中包含换行符，`scanf` 函数会将其作为输入的一部分，并将其存储在相应的变量中。这可能导致意外的行为，特别是当你在之后的输入中期望读取其他内容时。

为了解决这个问题，你可以在 `scanf` 格式字符串中使用空格来跳过换行符。空格字符会忽略输入中的所有空白字符，包括换行符。例如，你可以使用以下方式读取一个整数并跳过换行符：

```c
int num;
scanf("%d ", &num);
```

在上面的示例中，空格字符 `" "` 在格式字符串中的位置表示跳过一个或多个空白字符，直到遇到非空白字符为止。这样可以确保换行符不会干扰后续的输入。

另外，你还可以使用 `getchar` 函数来显式地读取并丢弃换行符。例如：

```c
int c;
while ((c = getchar()) != '\n' && c != EOF);
```

上面的代码会读取输入中的字符，直到遇到换行符或文件结束符（EOF），并丢弃这些字符。

通过这些方法，你可以处理输入中的换行符，以确保程序的行为符合预期。

## 指针

- 

```
int* ptr` 和 `int *ptr` 都是合法的写法，都表示声明一个指向 `int` 类型的指针变量 `ptr
```

在代码 int*  a, b, c;中，`a` 是一个指向 `int` 类型的指针，而 `b` 和 `c` 是 `int` 类型的变量。

相比之下，如果使用 `int  *a, b, c;` 的写法，`a`、`b` 和 `c` 都将被声明为指向 `int` 类型的指针。

因此，为了避免混淆，建议在声明指针变量时使用 `int* j` 的写法，这样可以更清晰地表达变量的类型。

- &i表示获取变量i的地址,& 运算符用于获取变量的地址

-   *j 表示查找j地址上存储的值。解引用操作符用于获取指针所指向地址处的值。



## extern

extern int x,y;//extern是一个关键字，用于声明一个全局变量或函数，表示该变量或函数是在其他文件中定义的。

编译时将当前文件和含有外部全局变量x、y的文件一起编译：gcc  4_extern.c  4_extern1.c -o  4_extern.out



<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240130155721133.png" alt="image-20240130155721133" style="zoom:67%;" />

## 数组

### 数组的长度

是在声明数组时指定的。**数组长度表示数组可以容纳的元素数量。**

有两种方式可以指定数组的长度：

1. 显式指定长度：在声明数组时明确指定数组的长度。例如，`int arr[5];` 声明了一个长度为 5 的整型数组。
2. 隐式推断长度：可以根据初始化的元素数量推断数组的长度。例如，`int arr[] = {1, 2, 3};` 声明了一个长度为 3 的整型数组，编译器会根据初始化的元素数量自动推断数组长度。

可以使用 `sizeof` 运算符来获取数组的长度。例如，`sizeof(arr)` 返回的是数组 `arr` 的总字节数，可以通过除以单个元素的字节数来计算数组的长度。例如，`sizeof(arr) / sizeof(arr[0])` 可以得到数组 `arr` 的元素数量。

需要注意的是，数组一旦声明后，其长度是固定的，不能动态改变。如果需要动态调整数组的长度，可以使用动态内存分配函数（如 `malloc` 和 `realloc`）来创建和调整数组的大小。

### 数组名

在 C 语言中，**数组名表示数组的地址，即数组首元素的地址**。当我们在声明和定义一个数组时，该数组名就代表着该数组的地址。

例如，在以下代码中：

```
int myArray[5] = {10, 20, 30, 40, 50};
```

在这里，myArray 是数组名，它表示整数类型的数组，包含 5 个元素。myArray 也代表着数组的地址，即第一个元素的地址。

数组名本身是一个常量指针，意味着它的值是不能被改变的，一旦确定，就不能再指向其他地方。

我们可以使用&运算符来获取数组的地址，如下所示：

```
int myArray[5] = {10, 20, 30, 40, 50};
int *ptr = &myArray[0]; // 或者直接写作 int *ptr = myArray;
```

在上面的例子中，ptr 指针变量被初始化为 myArray 的地址，即数组的第一个元素的地址。

重点理解**int *ptr = &myArray[0]; // 或者直接写作 int *ptr = myArray;**

需要注意的是，虽然数组名表示数组的地址，但在大多数情况下，数组名会自动转换为指向数组首元素的指针。这意味着我们可以直接将数组名用于指针运算，例如在函数传递参数或遍历数组时：

#### 实例

![image-20240130174508959](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240130174508959.png)

在上述代码中，printArray 函数接受一个整数数组和数组大小作为参数，我们将 myArray 数组名传递给函数，函数内部可以像使用指针一样使用 arr 数组名。

### 多维数组

### 静态数组和动态数组

#### 动态数组：

代码流程总结：

1. `calloc(size, sizeof(int))` 用于动态分配 `size` 个整型变量的内存空间，并将每个元素初始化为0。`sizeof(int)` 是每个整型变量的大小，用于计算总的内存空间大小。
2. 在 `if` 语句中检查动态内存分配是否成功。如果分配失败，即 `dynamicArray` 为 `NULL`，则打印错误消息并返回 1。
3. 用户被要求输入 `size` 个元素，并将它们存储到动态数组中。
4. 最后，打印动态数组的元素值。

请注意，修正后的代码中已经包含了对动态分配的内存空间的释放，使用 `free(dynamicArray)` 来释放内存，以防止内存泄漏。malloc/calloc 函数的返回类型是 void*,要转类型

## 共用体

**共用体**是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。

### 定义共用体

为了定义共用体，您必须使用 **union** 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：

![image-20240131203827302](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240131203827302.png)

**union tag** 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：

![image-20240131203809530](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240131203809530.png)

现在，**Data** 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。

**共用体占用的内存应足够存储共用体中最大的成员**。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小：

#### 实例

## ![image-20240131204004284](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240131204004284.png)



### 访问共用体成员

为了访问共用体的成员，我们使用**成员访问运算符（.）**。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 **union** 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法：

#### 实例

![image-20240131204143454](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240131204143454.png)

**Tips**:因为联合体的所有成员共享同一块内存空间，所以我们需要根据不同的成员类型来选择合适的操作方式。对于整数、浮点数等基本类型的成员，我们可以直接使用赋值运算符进行赋值。对于字符数组等复杂类型的成员，我们需要使用相关的函数进行操作，如字符串**复制函数 `strcpy`。**

当上面的代码被编译和执行时，它会产生下列结果：

![image-20240131204212302](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240131204212302.png)

在这里，我们可以看到共用体的 **i** 和 **f** 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 **str** 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的：

#### 实例

![image-20240131204414586](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240131204414586.png)

当上面的代码被编译和执行时，它会产生下列结果：

![image-20240131204427399](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240131204427399.png)

```

```

在这里，所有的成员都能完好输出，**因为同一时间只用到一个成员。**

## 枚举

## 计算机内存区域

### **栈（Stack）：**

- 栈是一种后进先出（LIFO）的数据结构。
- 栈的内存分配和释放是由编译器自动管理的，无需程序员手动操作。
- 栈的大小是固定的，由操作系统或编译器在程序运行之前确定。
- 栈用于存储**局部变量、函数调用和返回值**等临时数据。
- 栈的分配和释放速度很快。
- 栈上的数据在函数执行结束后会**自动释放**，无需手动管理内存。

### **堆（Heap）：**

- 堆是一种动态分配的内存区域。
- 堆的内存分配和释放是由程序员手动管理的，**通过调用动态内存分配函数（如 `malloc`、`calloc`、`realloc`）来分配内存，并使用 `free` 函数释放内存。**
- 堆的大小可以根据需要进行动态调整。
- 堆用于存储动态分配的数据，如动态数组、对象等。
- 堆的分配和释放速度相对较慢。
- 堆上的数据需要程序员手动管理内存，确保正确分配和释放，以避免内存泄漏或悬挂指针等问题。

总结来说，栈用于存储临时数据，由编译器自动管理内存，分配和释放速度快；而堆用于存储动态分配的数据，需要程序员手动管理内存，分配和释放速度相对较慢。了解堆和栈的区别对于正确使用内存和避免内存相关的错误非常重要。

### **静态数据区/全局数据区（Static Data/Global Data）**：

静态数据区用于存储全局变量、静态变量和常量等数据。这些数据在程序启动时就被分配，并在整个程序的执行期间都存在。

### **常量区（Constant Area）**：

常量区用于存储字符串常量和其他不可修改的常量数据。这些数据在程序运行期间保持不变。

### **代码区/文本区（Code/Text Area）**：

代码区存储程序的可执行代码，包括函数体的机器指令。这些指令在程序运行期间被执行。

![image-20240130001635376](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240130001635376.png)

作用域:局部 全局变量